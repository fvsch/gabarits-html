/* =======================================
 * FEUILLE DE STYLES DES GABARITS HTML/CSS
 * © Florens Verschelde pour Elephorm & Alsacreations.com
 * Licence: https://creativecommons.org/licenses/by/2.0/fr/
 * ======================================= */

/*
	Note: vous pouvez modifier simplement les couleurs de ce gabarit en
	modifiant uniquement les couleurs de fond (propriétés background-color)
	et les couleurs du texte (propriété color).
*/

/* Général */

html {
	/* Ces deux variables CSS nous permettent de gérer l'alignement du contenu
	de l'en-tête avec les autres blocs de la page.
	1. Par défaut, sur un petit écran, les principaux blocs de la page (en-tête,
		navigation, contenu) vont toucher les bords de l'écran, et le padding
		horizontal du body sera donc de zéro. L'en-tête a donc besoin d'un padding
		horizontal pour que son contenu ne touche pas les bords directement.
	2. Sur un écran plus large, tous les blocs de contenu seront affichés en
		retrait des bords de la page, avec un padding sur le body. Dans ce cas,
		le padding du header ne sera plus nécessaire, et on pourra le mettre à
		zéro pour avoir un meilleur alignement visuel.
	Les lignes suivantes définissent le premier cas de figure. Cherchez un peu
	plus loin dans la feuille de styles l'endroit où ces deux variables sont
	redéfinies pour le deuxième cas de figure.

	À noter: le nom des variables CSS est libre, du moment qu'il commence par
	un double tiret. On aurrait pu les appeller '--espace1' et '--espace2' ou
	tout autre nom. Mais il vaut mieux choisir des noms explicites pour s'y
	retrouver dans son propre code!
	*/
	--body-padding-inline: 0;
	--entete-padding-inline: 20px;

	color: #f0e39e;
	background-color: #2c2f22;
}

body {
	/* Nous allons réaliser la mise en page principale avec une grille CSS, et
	quatre zones nommées ("entete", "navigation", "contenu" et "pied").
	Par défaut, on commence par définir ces zones et les règles de création des
	lignes et colonnes. Par convention on commence par les styles les plus
	simples, qui sont souvent ceux pour les mobiles et autres petits écrans.
	Ici, on définit une seule colonne de pleine largeur ('1fr'), et quatre
	zones nommées dans 4 lignes séparées. Les contenus s'afficheront donc
	les uns sous les autres. */
	display: grid;
	grid-template-areas: "entete" "navigation" "contenu" "pied";
	grid-template-columns: 1fr;
}

@media (width >= 860px) {
	html {
		--body-padding-inline: 40px;
		--entete-padding-inline: 0;
	}

	body {
		/* On limite la largeur totale du conteneur et on le centre
		horizontalement avec des marges automatiques. */
		max-width: 1200px;
		margin-inline: auto;
		padding-block: 20px;
		padding-inline: var(--body-padding-inline);
	}

	/* On continue la définition de notre grille de mise en page, mais cette
	fois pour les écrans plus larges (860px et plus). */
	body.navigation-gauche {
		/* On souhaite une mise en page en deux colonnes, avec une première
		colonne de largeur fixe une autre de largeur variable: */
		grid-template-columns: 240px 1fr;
		/* On rédéfinit aussi nos 4 zones nommées, en gardant les mêmes noms
		(afin que les contenus placés avec 'grid-area' trouvent automatiquement
		leur place dans la grille redéfinie).
		- Chaque chaine de caractères placée entre guillemets correspond à une
			ligne de la grille.
		- On remarquera que deux zones sont sont définies comme occupant plusieurs
			"cellules" de la grille: "entete" sur deux colonnes, et "navigation"
			sur deux lignes.
		*/
		grid-template-areas:
			/* Première ligne: zone "entete" sur 2 colonnes */
			"entete entete"
			/* Deuxième ligne: zone "navigation" sur la première colonne, et "contenu" sur la seconde */
			"navigation contenu"
			/* Troisième ligne: zone "navigation" (à nouveau) sur la
				première colonne, et zone "pied" sur la seconde */
			"navigation pied";
		/* On souhaite que chaque ligne prenne la hauteur de son contenu, sauf la
	 	ligne du milieu ("navigation contenu") qui peut s'étendre en hauteur.
		Ce sera surtout utile si la navigation est haute et le contenu court. */
		grid-template-rows: auto 1fr auto;

		/* On ajoute une goutière de 20px entre colonnes uniquement */
		gap: 0px 20px;
	}

	/* Style similaire aux lignes ci-dessus, mais avec la zone "navigation"
	placée à droite */
	body.navigation-droite {
		grid-template-columns: 1fr 240px;
		grid-template-areas:
			"entete entete"
			"contenu navigation"
			"pied navigation";
		grid-template-rows: auto 1fr auto;
		gap: 0px 20px;
	}
}

a {
	color: #ff6533;
}

a:hover,
a:focus {
	color: #ff4c00;
}

strong {
	color: #a1b55d;
}

/* En-tête */

#entete {
	/* Un conteneur peut être à la fois enfant d'une grille CSS… */
	grid-area: entete;

	/* … et aussi définir une mise en page en grille ou flexbox pour ses
	propres enfants. (Pour la mise en page de cet en-tête avec "flexbox",
	voir les explications dans modele01.css.) */
	display: flex;
	flex-direction: column;
	gap: 20px;
	padding: 20px;

	@media (width >= 500px) {
		flex-direction: row;
		align-items: center;
	}

	@media (width >= 860px) {
		padding-inline: 0;
	}
}

#entete img {
	display: block;
	flex-shrink: 0;
}

#entete h1 {
	margin: 0;
	font-size: 2rem;
	line-height: 1.2;

	@media (width >= 500px) {
		font-size: 2.4rem;
	}
}

#entete p {
	margin: 4px 0;
}

/* Navigation */

#navigation {
	/* Ce conteneur doit être affiché dans la zone "navigation" de la grille
	CSS parente (définie avec 'grid-template-areas', 'grid-template-columns'
	et 'grid-template-rows'). */
	grid-area: navigation;

	/* Pour la mise en page de la liste des liens, nous allons utiliser les
	"container queries". Pour cela, nous devons définir ce conteneur comme
	étant l'espace de référence pour les conditions de dimensions (hauteur et
	largeur) de ses enfants et descendants. Pour cela on utilise la propriété
	CSS 'container-type'. */
	container-type: inline-size;

	background-color: #181a12;
}

#navigation ul {
	/* Par défaut, on affiche les liens en colonne, c'est à dire les uns sous
	les autres. (On pourrait réaliser le même affichage avec 'display: block',
	mais passer directement en Flexbox nous permet de faire varier l'affichage
	en changeant juste la valeur de 'flex-direction'.) */
	display: flex;
	flex-direction: column;
	gap: 4px;
	margin: 0;
	padding: 16px 10px;
	list-style: none;

	/* Lorsque l'espace horizontal disponible pour la liste de liens et de au
	moins 300px, on affiche les liens comme une liste horizontale. */
	@container (width >= 300px) {
		flex-direction: row;
		flex-wrap: wrap;
		align-items: center;
		padding-block: 10px;
	}
}

#navigation a {
	display: block;
	padding: 8px 12px;
	border-radius: 4px;
	line-height: 1.5;
	text-decoration: none;
	color: #ff6533;
}

#navigation a:hover,
#navigation a:focus {
	background-color: #000000;
}

/* Contenu principal */

#contenu {
	grid-area: contenu;
	padding: 20px;
	color: #363b29;
	background-color: #cbd888;
}

#contenu > :first-child {
	margin-top: 0;
}

#contenu p,
#contenu li {
	line-height: 1.5;
}

#contenu a {
	color: #332510;
}

#contenu a:hover,
#contenu a:focus {
	color: #6e5122;
}

#contenu strong {
	color: #181a12;
}

#contenu figure img {
	border-radius: 4px;
}

#contenu figcaption {
	font-size: 90%;
	text-align: center;
}

/* Pied de page */

#pied {
	grid-area: pied;
	padding: 15px 20px;
	font-size: 0.85em;
	color: #e6a948;
	background-color: #181a12;
}

#pied p {
	margin: 0.5em 0;
}

/* --- NOTES ---

1.	Ce gabarit utilise du padding sur l'élément BODY pour créer un retrait
	esthétique tout autour du conteneur principal.
	Rappel: "padding: 20px 50px;" se lit ainsi:
	- padding-top et padding-bottom de 20px;
	- padding-left et padding-right de 50px.

2.	C'est la propriété "float" qui nous permet de placer deux blocs
	côte-à-côte. Notez bien que l'élément flottant (ici, notre menu de
	navigation) doit être placé en premier dans le code HTML. Il est
	préférable de lui donner une largeur, ce que nous faisons ici avec un
	"width: 18%;".

3.	Correction d'un bug d'Internet Explorer 6. Voir la dernière partie de
	https://www.alsacreations.com/article/lire/626-impact-rendu-indentation-code.html
	Dans l'idéal, on placera ce correctif dans une feuille séparée, appelée
	via un commentaire conditionnel visant IE6.

4.	Les éléments flottants ne repoussent pas les blocs, mais repoussent
	uniquement leur contenu. Pour que notre bloc de contenu principal forme
	une colonne distincte du menu, on lui donne donc une marge à gauche de 20%.
	Il existe une autre technique pour adapter la largeur d'un bloc aux
	flottants qui le précèdent. On pourra lire l'article suivant:
		https://www.alsacreations.com/tuto/lire/588-trois-colonnes-float.html

*/
